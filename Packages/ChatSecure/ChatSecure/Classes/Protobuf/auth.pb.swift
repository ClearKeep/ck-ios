// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: auth.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Auth_BaseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_PeerRegisterClientKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var registrationID: Int32 = 0

  var deviceID: Int32 = 0

  var identityKeyPublic: Data = Data()

  var preKeyID: Int32 = 0

  var preKey: Data = Data()

  var signedPreKeyID: Int32 = 0

  var signedPreKey: Data = Data()

  var signedPreKeySignature: Data = Data()

  var identityKeyEncrypted: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response
struct Auth_PeerGetClientKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientID: String = String()

  var workspaceDomain: String = String()

  var registrationID: Int32 = 0

  var deviceID: Int32 = 0

  var identityKeyPublic: Data = Data()

  var preKeyID: Int32 = 0

  var preKey: Data = Data()

  var signedPreKeyID: Int32 = 0

  var signedPreKey: Data = Data()

  var signedPreKeySignature: Data = Data()

  var identityKeyEncrypted: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///Login message struct
struct Auth_AuthReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String = String()

  var email: String = String()

  var hashPassword: String = String()

  var authType: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_LogoutReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var refreshToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// fogot password
struct Auth_ForgotPasswordReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_ForgotPasswordUpdateReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preAccessToken: String = String()

  var email: String = String()

  var passwordVerifier: String = String()

  var salt: String = String()

  var ivParameter: String = String()

  var clientKeyPeer: Auth_PeerRegisterClientKeyRequest {
    get {return _clientKeyPeer ?? Auth_PeerRegisterClientKeyRequest()}
    set {_clientKeyPeer = newValue}
  }
  /// Returns true if `clientKeyPeer` has been explicitly set.
  var hasClientKeyPeer: Bool {return self._clientKeyPeer != nil}
  /// Clears the value of `clientKeyPeer`. Subsequent reads from it will return its default value.
  mutating func clearClientKeyPeer() {self._clientKeyPeer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _clientKeyPeer: Auth_PeerRegisterClientKeyRequest? = nil
}

struct Auth_AuthRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String {
    get {return _storage._workspaceDomain}
    set {_uniqueStorage()._workspaceDomain = newValue}
  }

  var workspaceName: String {
    get {return _storage._workspaceName}
    set {_uniqueStorage()._workspaceName = newValue}
  }

  var accessToken: String {
    get {return _storage._accessToken}
    set {_uniqueStorage()._accessToken = newValue}
  }

  var expiresIn: Int64 {
    get {return _storage._expiresIn}
    set {_uniqueStorage()._expiresIn = newValue}
  }

  var refreshExpiresIn: Int64 {
    get {return _storage._refreshExpiresIn}
    set {_uniqueStorage()._refreshExpiresIn = newValue}
  }

  var refreshToken: String {
    get {return _storage._refreshToken}
    set {_uniqueStorage()._refreshToken = newValue}
  }

  var tokenType: String {
    get {return _storage._tokenType}
    set {_uniqueStorage()._tokenType = newValue}
  }

  var sessionState: String {
    get {return _storage._sessionState}
    set {_uniqueStorage()._sessionState = newValue}
  }

  var scope: String {
    get {return _storage._scope}
    set {_uniqueStorage()._scope = newValue}
  }

  var hashKey: String {
    get {return _storage._hashKey}
    set {_uniqueStorage()._hashKey = newValue}
  }

  var sub: String {
    get {return _storage._sub}
    set {_uniqueStorage()._sub = newValue}
  }

  var preAccessToken: String {
    get {return _storage._preAccessToken}
    set {_uniqueStorage()._preAccessToken = newValue}
  }

  var requireAction: String {
    get {return _storage._requireAction}
    set {_uniqueStorage()._requireAction = newValue}
  }

  var salt: String {
    get {return _storage._salt}
    set {_uniqueStorage()._salt = newValue}
  }

  var clientKeyPeer: Auth_PeerGetClientKeyResponse {
    get {return _storage._clientKeyPeer ?? Auth_PeerGetClientKeyResponse()}
    set {_uniqueStorage()._clientKeyPeer = newValue}
  }
  /// Returns true if `clientKeyPeer` has been explicitly set.
  var hasClientKeyPeer: Bool {return _storage._clientKeyPeer != nil}
  /// Clears the value of `clientKeyPeer`. Subsequent reads from it will return its default value.
  mutating func clearClientKeyPeer() {_uniqueStorage()._clientKeyPeer = nil}

  var ivParameter: String {
    get {return _storage._ivParameter}
    set {_uniqueStorage()._ivParameter = newValue}
  }

  var error: String {
    get {return _storage._error}
    set {_uniqueStorage()._error = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Register message struct
struct Auth_RegisterReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String {
    get {return _storage._workspaceDomain}
    set {_uniqueStorage()._workspaceDomain = newValue}
  }

  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  var hashPassword: String {
    get {return _storage._hashPassword}
    set {_uniqueStorage()._hashPassword = newValue}
  }

  var authType: Int64 {
    get {return _storage._authType}
    set {_uniqueStorage()._authType = newValue}
  }

  var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  var salt: String {
    get {return _storage._salt}
    set {_uniqueStorage()._salt = newValue}
  }

  var clientKeyPeer: Auth_PeerRegisterClientKeyRequest {
    get {return _storage._clientKeyPeer ?? Auth_PeerRegisterClientKeyRequest()}
    set {_uniqueStorage()._clientKeyPeer = newValue}
  }
  /// Returns true if `clientKeyPeer` has been explicitly set.
  var hasClientKeyPeer: Bool {return _storage._clientKeyPeer != nil}
  /// Clears the value of `clientKeyPeer`. Subsequent reads from it will return its default value.
  mutating func clearClientKeyPeer() {_uniqueStorage()._clientKeyPeer = nil}

  var ivParameter: String {
    get {return _storage._ivParameter}
    set {_uniqueStorage()._ivParameter = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Auth_RegisterRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///Login Google message struct
struct Auth_GoogleLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String = String()

  var idToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///Login Office365 message struct
struct Auth_OfficeLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String = String()

  var accessToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///Login Facebook message struct
struct Auth_FacebookLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String = String()

  var accessToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_SocialLoginRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var requireAction: String = String()

  var resetPincodeToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Register a Pincode struct
struct Auth_RegisterPinCodeReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var hashPincode: String = String()

  var salt: String = String()

  var clientKeyPeer: Auth_PeerRegisterClientKeyRequest {
    get {return _clientKeyPeer ?? Auth_PeerRegisterClientKeyRequest()}
    set {_clientKeyPeer = newValue}
  }
  /// Returns true if `clientKeyPeer` has been explicitly set.
  var hasClientKeyPeer: Bool {return self._clientKeyPeer != nil}
  /// Clears the value of `clientKeyPeer`. Subsequent reads from it will return its default value.
  mutating func clearClientKeyPeer() {self._clientKeyPeer = nil}

  var ivParameter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _clientKeyPeer: Auth_PeerRegisterClientKeyRequest? = nil
}

/// Verify Pincode struct
struct Auth_VerifyPinCodeReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var clientPublic: String = String()

  var clientSessionKeyProof: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Reset Pincode, in case forgotten pincode
/// Note that reset pincode will also cause old message cannot be read
/// empty string indicate this field will be unchanging after update
struct Auth_ResetPinCodeReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resetPincodeToken: String = String()

  var userName: String = String()

  var hashPincode: String = String()

  var salt: String = String()

  var ivParameter: String = String()

  var clientKeyPeer: Auth_PeerRegisterClientKeyRequest {
    get {return _clientKeyPeer ?? Auth_PeerRegisterClientKeyRequest()}
    set {_clientKeyPeer = newValue}
  }
  /// Returns true if `clientKeyPeer` has been explicitly set.
  var hasClientKeyPeer: Bool {return self._clientKeyPeer != nil}
  /// Clears the value of `clientKeyPeer`. Subsequent reads from it will return its default value.
  mutating func clearClientKeyPeer() {self._clientKeyPeer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _clientKeyPeer: Auth_PeerRegisterClientKeyRequest? = nil
}

struct Auth_MfaValidateOtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preAccessToken: String = String()

  var otpCode: String = String()

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// we still need user_id and pre_access_token for author and authen user
struct Auth_MfaResendOtpReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var preAccessToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_MfaResendOtpRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preAccessToken: String = String()

  var success: Bool = false

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///new flow login with srp
///Login message struct
struct Auth_AuthChallengeReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var clientPublic: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_AuthSocialChallengeReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var clientPublic: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_AuthChallengeRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var salt: String = String()

  var publicChallengeB: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_AuthenticateReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var clientPublic: String = String()

  var clientSessionKeyProof: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Auth_RegisterSRPReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workspaceDomain: String {
    get {return _storage._workspaceDomain}
    set {_uniqueStorage()._workspaceDomain = newValue}
  }

  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var passwordVerifier: String {
    get {return _storage._passwordVerifier}
    set {_uniqueStorage()._passwordVerifier = newValue}
  }

  var salt: String {
    get {return _storage._salt}
    set {_uniqueStorage()._salt = newValue}
  }

  var clientKeyPeer: Auth_PeerRegisterClientKeyRequest {
    get {return _storage._clientKeyPeer ?? Auth_PeerRegisterClientKeyRequest()}
    set {_uniqueStorage()._clientKeyPeer = newValue}
  }
  /// Returns true if `clientKeyPeer` has been explicitly set.
  var hasClientKeyPeer: Bool {return _storage._clientKeyPeer != nil}
  /// Clears the value of `clientKeyPeer`. Subsequent reads from it will return its default value.
  mutating func clearClientKeyPeer() {_uniqueStorage()._clientKeyPeer = nil}

  var ivParameter: String {
    get {return _storage._ivParameter}
    set {_uniqueStorage()._ivParameter = newValue}
  }

  var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  var authType: Int64 {
    get {return _storage._authType}
    set {_uniqueStorage()._authType = newValue}
  }

  var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Auth_RegisterSRPRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "auth"

extension Auth_BaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_BaseResponse, rhs: Auth_BaseResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_PeerRegisterClientKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeerRegisterClientKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "registrationId"),
    2: .same(proto: "deviceId"),
    3: .same(proto: "identityKeyPublic"),
    4: .same(proto: "preKeyId"),
    5: .same(proto: "preKey"),
    6: .same(proto: "signedPreKeyId"),
    7: .same(proto: "signedPreKey"),
    8: .same(proto: "signedPreKeySignature"),
    9: .same(proto: "identityKeyEncrypted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.registrationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.identityKeyPublic) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.preKeyID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.preKey) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.signedPreKeyID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.signedPreKey) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.signedPreKeySignature) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.identityKeyEncrypted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.registrationID != 0 {
      try visitor.visitSingularInt32Field(value: self.registrationID, fieldNumber: 1)
    }
    if self.deviceID != 0 {
      try visitor.visitSingularInt32Field(value: self.deviceID, fieldNumber: 2)
    }
    if !self.identityKeyPublic.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKeyPublic, fieldNumber: 3)
    }
    if self.preKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.preKeyID, fieldNumber: 4)
    }
    if !self.preKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.preKey, fieldNumber: 5)
    }
    if self.signedPreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.signedPreKeyID, fieldNumber: 6)
    }
    if !self.signedPreKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPreKey, fieldNumber: 7)
    }
    if !self.signedPreKeySignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPreKeySignature, fieldNumber: 8)
    }
    if !self.identityKeyEncrypted.isEmpty {
      try visitor.visitSingularStringField(value: self.identityKeyEncrypted, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_PeerRegisterClientKeyRequest, rhs: Auth_PeerRegisterClientKeyRequest) -> Bool {
    if lhs.registrationID != rhs.registrationID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.identityKeyPublic != rhs.identityKeyPublic {return false}
    if lhs.preKeyID != rhs.preKeyID {return false}
    if lhs.preKey != rhs.preKey {return false}
    if lhs.signedPreKeyID != rhs.signedPreKeyID {return false}
    if lhs.signedPreKey != rhs.signedPreKey {return false}
    if lhs.signedPreKeySignature != rhs.signedPreKeySignature {return false}
    if lhs.identityKeyEncrypted != rhs.identityKeyEncrypted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_PeerGetClientKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeerGetClientKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientId"),
    2: .standard(proto: "workspace_domain"),
    3: .same(proto: "registrationId"),
    4: .same(proto: "deviceId"),
    5: .same(proto: "identityKeyPublic"),
    6: .same(proto: "preKeyId"),
    7: .same(proto: "preKey"),
    8: .same(proto: "signedPreKeyId"),
    9: .same(proto: "signedPreKey"),
    10: .same(proto: "signedPreKeySignature"),
    11: .same(proto: "identityKeyEncrypted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceDomain) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.registrationID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.deviceID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.identityKeyPublic) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.preKeyID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.preKey) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.signedPreKeyID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.signedPreKey) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.signedPreKeySignature) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.identityKeyEncrypted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.workspaceDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDomain, fieldNumber: 2)
    }
    if self.registrationID != 0 {
      try visitor.visitSingularInt32Field(value: self.registrationID, fieldNumber: 3)
    }
    if self.deviceID != 0 {
      try visitor.visitSingularInt32Field(value: self.deviceID, fieldNumber: 4)
    }
    if !self.identityKeyPublic.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKeyPublic, fieldNumber: 5)
    }
    if self.preKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.preKeyID, fieldNumber: 6)
    }
    if !self.preKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.preKey, fieldNumber: 7)
    }
    if self.signedPreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.signedPreKeyID, fieldNumber: 8)
    }
    if !self.signedPreKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPreKey, fieldNumber: 9)
    }
    if !self.signedPreKeySignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPreKeySignature, fieldNumber: 10)
    }
    if !self.identityKeyEncrypted.isEmpty {
      try visitor.visitSingularStringField(value: self.identityKeyEncrypted, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_PeerGetClientKeyResponse, rhs: Auth_PeerGetClientKeyResponse) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.workspaceDomain != rhs.workspaceDomain {return false}
    if lhs.registrationID != rhs.registrationID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.identityKeyPublic != rhs.identityKeyPublic {return false}
    if lhs.preKeyID != rhs.preKeyID {return false}
    if lhs.preKey != rhs.preKey {return false}
    if lhs.signedPreKeyID != rhs.signedPreKeyID {return false}
    if lhs.signedPreKey != rhs.signedPreKey {return false}
    if lhs.signedPreKeySignature != rhs.signedPreKeySignature {return false}
    if lhs.identityKeyEncrypted != rhs.identityKeyEncrypted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_AuthReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .same(proto: "email"),
    3: .standard(proto: "hash_password"),
    4: .standard(proto: "auth_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workspaceDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hashPassword) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.authType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workspaceDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDomain, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.hashPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.hashPassword, fieldNumber: 3)
    }
    if self.authType != 0 {
      try visitor.visitSingularInt64Field(value: self.authType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_AuthReq, rhs: Auth_AuthReq) -> Bool {
    if lhs.workspaceDomain != rhs.workspaceDomain {return false}
    if lhs.email != rhs.email {return false}
    if lhs.hashPassword != rhs.hashPassword {return false}
    if lhs.authType != rhs.authType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_LogoutReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogoutReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "refresh_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_LogoutReq, rhs: Auth_LogoutReq) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_ForgotPasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForgotPasswordReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_ForgotPasswordReq, rhs: Auth_ForgotPasswordReq) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_ForgotPasswordUpdateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForgotPasswordUpdateReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_access_token"),
    2: .same(proto: "email"),
    3: .standard(proto: "password_verifier"),
    4: .same(proto: "salt"),
    5: .standard(proto: "iv_parameter"),
    6: .standard(proto: "client_key_peer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preAccessToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.passwordVerifier) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ivParameter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._clientKeyPeer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.preAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.preAccessToken, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.passwordVerifier.isEmpty {
      try visitor.visitSingularStringField(value: self.passwordVerifier, fieldNumber: 3)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 4)
    }
    if !self.ivParameter.isEmpty {
      try visitor.visitSingularStringField(value: self.ivParameter, fieldNumber: 5)
    }
    try { if let v = self._clientKeyPeer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_ForgotPasswordUpdateReq, rhs: Auth_ForgotPasswordUpdateReq) -> Bool {
    if lhs.preAccessToken != rhs.preAccessToken {return false}
    if lhs.email != rhs.email {return false}
    if lhs.passwordVerifier != rhs.passwordVerifier {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.ivParameter != rhs.ivParameter {return false}
    if lhs._clientKeyPeer != rhs._clientKeyPeer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_AuthRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .standard(proto: "workspace_name"),
    3: .standard(proto: "access_token"),
    4: .standard(proto: "expires_in"),
    5: .standard(proto: "refresh_expires_in"),
    6: .standard(proto: "refresh_token"),
    7: .standard(proto: "token_type"),
    8: .standard(proto: "session_state"),
    9: .same(proto: "scope"),
    10: .standard(proto: "hash_key"),
    11: .same(proto: "sub"),
    12: .standard(proto: "pre_access_token"),
    13: .standard(proto: "require_action"),
    14: .same(proto: "salt"),
    15: .standard(proto: "client_key_peer"),
    16: .standard(proto: "iv_parameter"),
    17: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _workspaceDomain: String = String()
    var _workspaceName: String = String()
    var _accessToken: String = String()
    var _expiresIn: Int64 = 0
    var _refreshExpiresIn: Int64 = 0
    var _refreshToken: String = String()
    var _tokenType: String = String()
    var _sessionState: String = String()
    var _scope: String = String()
    var _hashKey: String = String()
    var _sub: String = String()
    var _preAccessToken: String = String()
    var _requireAction: String = String()
    var _salt: String = String()
    var _clientKeyPeer: Auth_PeerGetClientKeyResponse? = nil
    var _ivParameter: String = String()
    var _error: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workspaceDomain = source._workspaceDomain
      _workspaceName = source._workspaceName
      _accessToken = source._accessToken
      _expiresIn = source._expiresIn
      _refreshExpiresIn = source._refreshExpiresIn
      _refreshToken = source._refreshToken
      _tokenType = source._tokenType
      _sessionState = source._sessionState
      _scope = source._scope
      _hashKey = source._hashKey
      _sub = source._sub
      _preAccessToken = source._preAccessToken
      _requireAction = source._requireAction
      _salt = source._salt
      _clientKeyPeer = source._clientKeyPeer
      _ivParameter = source._ivParameter
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workspaceDomain) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workspaceName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._accessToken) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._expiresIn) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._refreshExpiresIn) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._refreshToken) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._tokenType) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._sessionState) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._scope) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._hashKey) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._sub) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._preAccessToken) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._requireAction) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._salt) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._clientKeyPeer) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._ivParameter) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._error) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workspaceDomain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workspaceDomain, fieldNumber: 1)
      }
      if !_storage._workspaceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workspaceName, fieldNumber: 2)
      }
      if !_storage._accessToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accessToken, fieldNumber: 3)
      }
      if _storage._expiresIn != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expiresIn, fieldNumber: 4)
      }
      if _storage._refreshExpiresIn != 0 {
        try visitor.visitSingularInt64Field(value: _storage._refreshExpiresIn, fieldNumber: 5)
      }
      if !_storage._refreshToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refreshToken, fieldNumber: 6)
      }
      if !_storage._tokenType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokenType, fieldNumber: 7)
      }
      if !_storage._sessionState.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionState, fieldNumber: 8)
      }
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 9)
      }
      if !_storage._hashKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hashKey, fieldNumber: 10)
      }
      if !_storage._sub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sub, fieldNumber: 11)
      }
      if !_storage._preAccessToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preAccessToken, fieldNumber: 12)
      }
      if !_storage._requireAction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requireAction, fieldNumber: 13)
      }
      if !_storage._salt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._salt, fieldNumber: 14)
      }
      try { if let v = _storage._clientKeyPeer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._ivParameter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ivParameter, fieldNumber: 16)
      }
      if !_storage._error.isEmpty {
        try visitor.visitSingularStringField(value: _storage._error, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_AuthRes, rhs: Auth_AuthRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workspaceDomain != rhs_storage._workspaceDomain {return false}
        if _storage._workspaceName != rhs_storage._workspaceName {return false}
        if _storage._accessToken != rhs_storage._accessToken {return false}
        if _storage._expiresIn != rhs_storage._expiresIn {return false}
        if _storage._refreshExpiresIn != rhs_storage._refreshExpiresIn {return false}
        if _storage._refreshToken != rhs_storage._refreshToken {return false}
        if _storage._tokenType != rhs_storage._tokenType {return false}
        if _storage._sessionState != rhs_storage._sessionState {return false}
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._hashKey != rhs_storage._hashKey {return false}
        if _storage._sub != rhs_storage._sub {return false}
        if _storage._preAccessToken != rhs_storage._preAccessToken {return false}
        if _storage._requireAction != rhs_storage._requireAction {return false}
        if _storage._salt != rhs_storage._salt {return false}
        if _storage._clientKeyPeer != rhs_storage._clientKeyPeer {return false}
        if _storage._ivParameter != rhs_storage._ivParameter {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_RegisterReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .same(proto: "email"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "hash_password"),
    5: .standard(proto: "auth_type"),
    6: .standard(proto: "first_name"),
    7: .standard(proto: "last_name"),
    8: .same(proto: "salt"),
    9: .standard(proto: "client_key_peer"),
    10: .standard(proto: "iv_parameter"),
  ]

  fileprivate class _StorageClass {
    var _workspaceDomain: String = String()
    var _email: String = String()
    var _displayName: String = String()
    var _hashPassword: String = String()
    var _authType: Int64 = 0
    var _firstName: String = String()
    var _lastName: String = String()
    var _salt: String = String()
    var _clientKeyPeer: Auth_PeerRegisterClientKeyRequest? = nil
    var _ivParameter: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workspaceDomain = source._workspaceDomain
      _email = source._email
      _displayName = source._displayName
      _hashPassword = source._hashPassword
      _authType = source._authType
      _firstName = source._firstName
      _lastName = source._lastName
      _salt = source._salt
      _clientKeyPeer = source._clientKeyPeer
      _ivParameter = source._ivParameter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workspaceDomain) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hashPassword) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._authType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._salt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._clientKeyPeer) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._ivParameter) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workspaceDomain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workspaceDomain, fieldNumber: 1)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 2)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 3)
      }
      if !_storage._hashPassword.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hashPassword, fieldNumber: 4)
      }
      if _storage._authType != 0 {
        try visitor.visitSingularInt64Field(value: _storage._authType, fieldNumber: 5)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 6)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 7)
      }
      if !_storage._salt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._salt, fieldNumber: 8)
      }
      try { if let v = _storage._clientKeyPeer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._ivParameter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ivParameter, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_RegisterReq, rhs: Auth_RegisterReq) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workspaceDomain != rhs_storage._workspaceDomain {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._hashPassword != rhs_storage._hashPassword {return false}
        if _storage._authType != rhs_storage._authType {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._salt != rhs_storage._salt {return false}
        if _storage._clientKeyPeer != rhs_storage._clientKeyPeer {return false}
        if _storage._ivParameter != rhs_storage._ivParameter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_RegisterRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_RegisterRes, rhs: Auth_RegisterRes) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_GoogleLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GoogleLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .standard(proto: "id_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workspaceDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workspaceDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDomain, fieldNumber: 1)
    }
    if !self.idToken.isEmpty {
      try visitor.visitSingularStringField(value: self.idToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_GoogleLoginReq, rhs: Auth_GoogleLoginReq) -> Bool {
    if lhs.workspaceDomain != rhs.workspaceDomain {return false}
    if lhs.idToken != rhs.idToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_OfficeLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OfficeLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .standard(proto: "access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workspaceDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workspaceDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDomain, fieldNumber: 1)
    }
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_OfficeLoginReq, rhs: Auth_OfficeLoginReq) -> Bool {
    if lhs.workspaceDomain != rhs.workspaceDomain {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_FacebookLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FacebookLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .standard(proto: "access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workspaceDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workspaceDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDomain, fieldNumber: 1)
    }
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_FacebookLoginReq, rhs: Auth_FacebookLoginReq) -> Bool {
    if lhs.workspaceDomain != rhs.workspaceDomain {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_SocialLoginRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SocialLoginRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "require_action"),
    3: .standard(proto: "reset_pincode_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requireAction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resetPincodeToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.requireAction.isEmpty {
      try visitor.visitSingularStringField(value: self.requireAction, fieldNumber: 2)
    }
    if !self.resetPincodeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.resetPincodeToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_SocialLoginRes, rhs: Auth_SocialLoginRes) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.requireAction != rhs.requireAction {return false}
    if lhs.resetPincodeToken != rhs.resetPincodeToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_RegisterPinCodeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterPinCodeReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "hash_pincode"),
    3: .same(proto: "salt"),
    4: .standard(proto: "client_key_peer"),
    5: .standard(proto: "iv_parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hashPincode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientKeyPeer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ivParameter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.hashPincode.isEmpty {
      try visitor.visitSingularStringField(value: self.hashPincode, fieldNumber: 2)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 3)
    }
    try { if let v = self._clientKeyPeer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.ivParameter.isEmpty {
      try visitor.visitSingularStringField(value: self.ivParameter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_RegisterPinCodeReq, rhs: Auth_RegisterPinCodeReq) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.hashPincode != rhs.hashPincode {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs._clientKeyPeer != rhs._clientKeyPeer {return false}
    if lhs.ivParameter != rhs.ivParameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_VerifyPinCodeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyPinCodeReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "client_public"),
    3: .standard(proto: "client_session_key_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientPublic) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientSessionKeyProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.clientPublic.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPublic, fieldNumber: 2)
    }
    if !self.clientSessionKeyProof.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSessionKeyProof, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_VerifyPinCodeReq, rhs: Auth_VerifyPinCodeReq) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.clientPublic != rhs.clientPublic {return false}
    if lhs.clientSessionKeyProof != rhs.clientSessionKeyProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_ResetPinCodeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetPinCodeReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reset_pincode_token"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "hash_pincode"),
    4: .same(proto: "salt"),
    5: .standard(proto: "iv_parameter"),
    6: .standard(proto: "client_key_peer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resetPincodeToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hashPincode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ivParameter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._clientKeyPeer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resetPincodeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.resetPincodeToken, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.hashPincode.isEmpty {
      try visitor.visitSingularStringField(value: self.hashPincode, fieldNumber: 3)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 4)
    }
    if !self.ivParameter.isEmpty {
      try visitor.visitSingularStringField(value: self.ivParameter, fieldNumber: 5)
    }
    try { if let v = self._clientKeyPeer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_ResetPinCodeReq, rhs: Auth_ResetPinCodeReq) -> Bool {
    if lhs.resetPincodeToken != rhs.resetPincodeToken {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.hashPincode != rhs.hashPincode {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.ivParameter != rhs.ivParameter {return false}
    if lhs._clientKeyPeer != rhs._clientKeyPeer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_MfaValidateOtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MfaValidateOtpRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_access_token"),
    2: .standard(proto: "otp_code"),
    3: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preAccessToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.otpCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.preAccessToken, fieldNumber: 1)
    }
    if !self.otpCode.isEmpty {
      try visitor.visitSingularStringField(value: self.otpCode, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_MfaValidateOtpRequest, rhs: Auth_MfaValidateOtpRequest) -> Bool {
    if lhs.preAccessToken != rhs.preAccessToken {return false}
    if lhs.otpCode != rhs.otpCode {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_MfaResendOtpReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MfaResendOtpReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "pre_access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.preAccessToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.preAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.preAccessToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_MfaResendOtpReq, rhs: Auth_MfaResendOtpReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.preAccessToken != rhs.preAccessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_MfaResendOtpRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MfaResendOtpRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_access_token"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preAccessToken) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.preAccessToken, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_MfaResendOtpRes, rhs: Auth_MfaResendOtpRes) -> Bool {
    if lhs.preAccessToken != rhs.preAccessToken {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_AuthChallengeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthChallengeReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .standard(proto: "client_public"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientPublic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.clientPublic.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPublic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_AuthChallengeReq, rhs: Auth_AuthChallengeReq) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.clientPublic != rhs.clientPublic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_AuthSocialChallengeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthSocialChallengeReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "client_public"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientPublic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.clientPublic.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPublic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_AuthSocialChallengeReq, rhs: Auth_AuthSocialChallengeReq) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.clientPublic != rhs.clientPublic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_AuthChallengeRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthChallengeRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "salt"),
    2: .standard(proto: "public_challenge_b"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicChallengeB) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 1)
    }
    if !self.publicChallengeB.isEmpty {
      try visitor.visitSingularStringField(value: self.publicChallengeB, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_AuthChallengeRes, rhs: Auth_AuthChallengeRes) -> Bool {
    if lhs.salt != rhs.salt {return false}
    if lhs.publicChallengeB != rhs.publicChallengeB {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_AuthenticateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "client_public"),
    3: .standard(proto: "client_session_key_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientPublic) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientSessionKeyProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.clientPublic.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPublic, fieldNumber: 2)
    }
    if !self.clientSessionKeyProof.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSessionKeyProof, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_AuthenticateReq, rhs: Auth_AuthenticateReq) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.clientPublic != rhs.clientPublic {return false}
    if lhs.clientSessionKeyProof != rhs.clientSessionKeyProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_RegisterSRPReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterSRPReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_domain"),
    2: .same(proto: "email"),
    3: .standard(proto: "password_verifier"),
    4: .same(proto: "salt"),
    5: .standard(proto: "client_key_peer"),
    6: .standard(proto: "iv_parameter"),
    7: .standard(proto: "display_name"),
    8: .standard(proto: "auth_type"),
    9: .standard(proto: "first_name"),
    10: .standard(proto: "last_name"),
  ]

  fileprivate class _StorageClass {
    var _workspaceDomain: String = String()
    var _email: String = String()
    var _passwordVerifier: String = String()
    var _salt: String = String()
    var _clientKeyPeer: Auth_PeerRegisterClientKeyRequest? = nil
    var _ivParameter: String = String()
    var _displayName: String = String()
    var _authType: Int64 = 0
    var _firstName: String = String()
    var _lastName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workspaceDomain = source._workspaceDomain
      _email = source._email
      _passwordVerifier = source._passwordVerifier
      _salt = source._salt
      _clientKeyPeer = source._clientKeyPeer
      _ivParameter = source._ivParameter
      _displayName = source._displayName
      _authType = source._authType
      _firstName = source._firstName
      _lastName = source._lastName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workspaceDomain) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._passwordVerifier) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._salt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._clientKeyPeer) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._ivParameter) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._authType) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workspaceDomain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workspaceDomain, fieldNumber: 1)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 2)
      }
      if !_storage._passwordVerifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._passwordVerifier, fieldNumber: 3)
      }
      if !_storage._salt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._salt, fieldNumber: 4)
      }
      try { if let v = _storage._clientKeyPeer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._ivParameter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ivParameter, fieldNumber: 6)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 7)
      }
      if _storage._authType != 0 {
        try visitor.visitSingularInt64Field(value: _storage._authType, fieldNumber: 8)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 9)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_RegisterSRPReq, rhs: Auth_RegisterSRPReq) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workspaceDomain != rhs_storage._workspaceDomain {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._passwordVerifier != rhs_storage._passwordVerifier {return false}
        if _storage._salt != rhs_storage._salt {return false}
        if _storage._clientKeyPeer != rhs_storage._clientKeyPeer {return false}
        if _storage._ivParameter != rhs_storage._ivParameter {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._authType != rhs_storage._authType {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Auth_RegisterSRPRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterSRPRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Auth_RegisterSRPRes, rhs: Auth_RegisterSRPRes) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
